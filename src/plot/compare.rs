//! Comparative plot.

use common::* ;
use common::plot::* ;
use errors::* ;

/// Generates the comparative scatterplot between two tools.
pub fn work(conf: & PlotConf, file_1: String, file_2: String) -> Res<()> {
  log!{ conf => "Loading tool data..." }
  let mut run_res = ::common::res::RunRes::of_files(
    vec![ file_1.clone(), file_2.clone() ]
  ) ? ;

  let mut res_2 = if let Some(res) = run_res.tools.pop() { res } else {
    bail!("[bug] there's no data in this run result")
  } ;
  let mut res_1 = if let Some(res) = run_res.tools.pop() { res } else {
    bail!("[bug] there was only one tool result in this run result")
  } ;
  if ! run_res.tools.is_empty() {
    bail!("[bug] there was more than two tool results in this run result")
  }

  let has_errs = res_1.err_count + res_2.err_count > 0 ;

  if res_1.suc_count == 0 {
    warn!(
      conf =>
        "data for `{}`: everything is timeout or error",
        conf.bad(& res_1.tool.name)
    )
  }
  if res_2.suc_count == 0 {
    warn!(
      conf =>
        "data for `{}`: everything is timeout or error",
        conf.bad(& res_2.tool.name)
    )
  }

  let (lo_time, hi_time) = match (
    res_1.time_interval(), res_2.time_interval()
  ) {
    (None, None) => (
      Duration::zero(), ::std::cmp::max(res_1.timeout, res_2.timeout)
    ),
    ( Some((lo, hi)), None ) => (lo, hi),
    ( None, Some((lo, hi)) ) => (lo, hi),
    ( Some((lo1, hi1)), Some((lo2, hi2)) ) => (
      ::std::cmp::min(lo1, lo2), ::std::cmp::max(hi1, hi2)
    ),
  } ;
  let tmo_time = hi_time + hi_time / 10 ;
  let err_time = hi_time + hi_time / 5 ;
  let min_time = lo_time - lo_time / 10 ;

  log!{
    conf => "Generating comparative scatterplot..." ; {
      log!{ conf, verb => "  loading data files..." }
    }
  }

  let (mut data_file, data_file_path) = {
    let mut path = PathBuf::from(& conf.file) ;
    let success = path.set_extension("data") ;
    if ! success {
      bail!(
        format!("illegal plot file name `{}`", conf.bad(& conf.file))
      )
    }
    (
      conf.open_file_writer(& path).chain_err(
        || format!(
          "while opening comparative data file `{}`",
          conf.sad( path.to_string_lossy() )
        )
      ) ?,
      path
    )
  } ;
  writeln!(
    data_file, "# Generated by {} v{}\n\n", crate_name!(), crate_version!()
  ).and_then(
    |_| writeln!(
      data_file, "# `{}` VERSUS `{}`\n", res_1.tool.name, res_2.tool.name
    )
  ).chain_err(
    || format!(
      "while writing to comparative data file `{}`",
      conf.sad( data_file_path.to_string_lossy() )
    )
  ) ? ;

  let mut not_in_res_2 = vec![] ;
  let (mut dble_tmos, mut dble_errs) = (0, 0) ;

  for (bench, res_1) in res_1.res.drain() {
    if let Some(res_2) = res_2.res.remove(& bench) {
      if res_1.is_tmo() && res_2.is_tmo() {
        dble_tmos += 1
      } else if res_1.is_err() && res_2.is_err() {
        dble_errs += 1
      }
      writeln!(
        data_file, "{} {}", res_1.map(
          |time, _| time, || tmo_time, || err_time
        ).as_sec_str(), res_2.map(
          |time, _| time, || tmo_time, || err_time
        ).as_sec_str()
      ).chain_err(
        || format!(
          "while writing to comparative data file `{}`",
          conf.sad( data_file_path.to_string_lossy() )
        )
      ) ?
    } else {
      not_in_res_2.push(bench)
    }
  }

  if ! not_in_res_2.is_empty() || ! res_2.res.is_empty() {
    warn!(
      conf => {
        if ! not_in_res_2.is_empty() {
          warn!(
            conf, line =>
              "found {} benchmarks in `{}`'s data that are not in `{}`'s",
              conf.sad(& format!("{}", not_in_res_2.len())),
              conf.emph(& res_1.tool.name),
              conf.emph(& res_2.tool.name)
          )
        }
        if ! res_2.res.is_empty() {
          warn!(
            conf, line =>
              "found {} benchmarks in `{}`'s data that are not in `{}`'s",
              conf.sad(& format!("{}", res_2.res.len())),
              conf.emph(& res_2.tool.name),
              conf.emph(& res_1.tool.name)
          )
        }
      }
    )
  }


  let output_file = {
    let mut path = PathBuf::from(& conf.file) ;
    let worked = path.set_extension( conf.fmt.ext() ) ;
    if ! worked {
      bail!(
        format!("illegal plot file `{}`", conf.file)
      )
    }
    if let Some(s) = path.to_str() {
      s.to_string()
    } else {
      bail!(
        format!("illegal plot file `{}`", conf.file)
      )
    }
  } ;

  log!{
    conf, verb =>
    "  writing plot file `{}`...", conf.emph(& conf.file) ;
    "  (output pdf file is `{}`)", conf.emph(& output_file) ;
  }

  let mut file = conf.open_file_writer(& conf.file).chain_err(
    || format!(
      "while opening comparative plot file `{}` (write)", conf.emph(& conf.file)
    )
  ) ? ;

  // let _title = if timeouts_1 + errors_1 + timeouts_2 + errors_2 > 0 {
  //   let mut title = format!(
  //     "\
  //       {}: {} timeouts and {} errors\\n\
  //       {}: {} timeouts and {} errors\
  //     ",
  //     data_1.tool.name, timeouts_1, errors_1,
  //     data_2.tool.name, timeouts_2, errors_2,
  //   ) ;
  //   if dble_timeouts > 0 {
  //     log!{
  //       conf => "  {} {}", dble_timeouts, conf.sad("double timeouts")
  //     }
  //     title = format!(
  //       "{}\\n{} double timeouts (both timeout-ed)", title, dble_timeouts
  //     )
  //   }
  //   if dble_errors > 0 {
  //     log!{
  //       conf => "  {} {}", dble_errors, conf.bad("double errors")
  //     }
  //     title = format!(
  //       "{}\\n{} double errors (both failed)", title, dble_errors
  //     )
  //   }
  //   format!("set title \"{}\"", title)
  // } else { "".into() } ;

  // println!("err time: {}, tmo time: {}", err_time, tmo_time) ;

  let title = format!(
    "set title '{} double timeout{}, {} double error{}' font ',13'\n\n",
    dble_tmos, if dble_tmos == 1 {""} else {"s"},
    dble_errs, if dble_errs == 1 {""} else {"s"},
  ) ;

  let (
    vert_err_line, horz_err_line, max_range
  ) = if ! has_errs {
    ( "".to_string(), "".to_string(), (tmo_time + tmo_time / 10).as_sec_str() )
  } else {(
    format!(
      "\
# Error vertical line.
set arrow from {}, graph 0 to {}, graph 1 nohead ls 4\n\
      ", err_time.as_sec_str(), err_time.as_sec_str()
    ),
    format!(
      "
  {} t 'Error' with lines ls 4, \\\
      ", err_time.as_sec_str()
    ),
    (err_time + err_time / 10).as_sec_str()
  )} ;

  file.write_all(
    format!(
      "# Generated by {} v{}\n\n{}\n",
      crate_name!(), crate_version!(), conf.fmt.term()
    ).as_bytes()
  ).and_then(
    |()| file.write_all( plot_prefix.as_bytes() )
  ).and_then(
    |()| file.write_all(
      format!(
        "
set output \"{}\"

{}set xlabel \"{} (seconds, logscale)\" textcolor rgbcolor \"0x000000\"
set ylabel \"{} (seconds, logscale)\" textcolor rgbcolor \"0x000000\"

set xrange [{}:{}]
set yrange [{}:{}]

# Timeout vertical line.
set arrow from {}, graph 0 to {}, graph 1 nohead ls 3
{}

plot \\
  {} t 'Timeout' with lines ls 3, \\{}
  x notitle with lines ls 2, \\
  '{}' using 1:2 notitle with points ls 1
\
        ", output_file,
        if dble_tmos + dble_errs > 0 { title } else { "".into() },
        res_1.tool.graph, res_2.tool.graph,
        min_time.as_sec_str(), max_range,
        min_time.as_sec_str(), max_range,
        tmo_time.as_sec_str(), tmo_time.as_sec_str(),
        vert_err_line,
        tmo_time.as_sec_str(), horz_err_line,
        data_file_path.to_string_lossy()
      ).as_bytes()
    )
  ).chain_err(
    || format!(
      "while writing to comparative plot file `{}`", conf.emph(& conf.file)
    )
  ) ? ;

  if conf.pdf {
    log!{ conf, verb => "  running gnuplot..." }
    // Run gnuplot.
    let status = Command::new("gnuplot").arg(& conf.file).status().chain_err(
      || format!(
        "while running gnuplot command on `{}`", conf.emph(& conf.file)
      )
    ) ? ;

    if ! status.success() {
      bail!(
        format!("gnuplot failed on plot file `{}`", conf.emph(& conf.file))
      )
    }

    if let Some(ref cmd) = conf.then {
      log!{ conf, verb => "  running user-provided command" }
      let status = Command::new(cmd).arg(& output_file).status().chain_err(
        || format!(
          "while running `{} {}` (user-provided command)",
          conf.emph(cmd), conf.emph(& output_file)
        )
      ) ? ;
      if ! status.success() {
        bail!(
          format!(
            "failure on user-provided command `{} {}`",
            conf.emph(cmd), conf.emph(& output_file)
          )
        )
      }
    }
  }

  log!{ conf => "Done" }

  Ok(())
}



static plot_prefix: & str = r#"

set border 3 linecolor rgbcolor "0x000000"
set xtics nomirror
set ytics nomirror
set grid
set key textcolor rgbcolor "0x000000"

set size ratio 1

# For points.
set style line 1 lt 1 dt 1 lw 2 pt 1 linecolor rgb "0x3333FF"
# For y = x.
set style line 2 lt 1 dt 1 lw 1 pt 3 linecolor rgb "0xA0A0A0"
# For timeouts.
set style line 3 lt 1 dt 1 lw 2 pt 3 linecolor rgb "0xFF9933"
# For errors.
set style line 4 lt 1 dt 1 lw 2 pt 3 linecolor rgb "0xFF0000"

unset key
set logscale x
set logscale y

set key above maxrows 1 samplen 2 font ",11"
"# ;